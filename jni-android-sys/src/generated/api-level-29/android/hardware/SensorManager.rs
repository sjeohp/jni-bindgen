// WARNING:  This file was autogenerated by jni-bindgen.  Any changes to this file may be lost!!!


#[cfg(any(feature = "all", feature = "android-hardware-SensorManager"))]
__jni_bindgen! {
    /// public class [SensorManager](https://developer.android.com/reference/android/hardware/SensorManager.html)
    ///
    /// Required feature: android-hardware-SensorManager
    public class SensorManager ("android/hardware/SensorManager") extends crate::java::lang::Object {

        // // Not emitting: Non-public method
        // /// [SensorManager](https://developer.android.com/reference/android/hardware/SensorManager.html#SensorManager())
        // fn new<'env>(__jni_env: &'env __jni_bindgen::Env) -> __jni_bindgen::std::result::Result<__jni_bindgen::Local<'env, crate::android::hardware::SensorManager>, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
        //     // class.path == "android/hardware/SensorManager", java.flags == (empty), .name == "<init>", .descriptor == "()V"
        //     unsafe {
        //         let __jni_args = [];
        //         let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "<init>\0", "()V\0");
        //         __jni_env.new_object_a(__jni_class, __jni_method, __jni_args.as_ptr())
        //     }
        // }

        /// [getSensors](https://developer.android.com/reference/android/hardware/SensorManager.html#getSensors())
        #[deprecated] pub fn getSensors<'env>(&'env self) -> __jni_bindgen::std::result::Result<i32, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "getSensors", .descriptor == "()I"
            unsafe {
                let __jni_args = [];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "getSensors\0", "()I\0");
                __jni_env.call_int_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [getSensorList](https://developer.android.com/reference/android/hardware/SensorManager.html#getSensorList(int))
        ///
        /// Required features: "java-util-List"
        #[cfg(any(feature = "all", all(feature = "java-util-List")))]
        pub fn getSensorList<'env>(&'env self, arg0: i32) -> __jni_bindgen::std::result::Result<__jni_bindgen::std::option::Option<__jni_bindgen::Local<'env, crate::java::util::List>>, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "getSensorList", .descriptor == "(I)Ljava/util/List;"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0)];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "getSensorList\0", "(I)Ljava/util/List;\0");
                __jni_env.call_object_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [getDynamicSensorList](https://developer.android.com/reference/android/hardware/SensorManager.html#getDynamicSensorList(int))
        ///
        /// Required features: "java-util-List"
        #[cfg(any(feature = "all", all(feature = "java-util-List")))]
        pub fn getDynamicSensorList<'env>(&'env self, arg0: i32) -> __jni_bindgen::std::result::Result<__jni_bindgen::std::option::Option<__jni_bindgen::Local<'env, crate::java::util::List>>, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "getDynamicSensorList", .descriptor == "(I)Ljava/util/List;"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0)];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "getDynamicSensorList\0", "(I)Ljava/util/List;\0");
                __jni_env.call_object_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [getDefaultSensor](https://developer.android.com/reference/android/hardware/SensorManager.html#getDefaultSensor(int))
        ///
        /// Required features: "android-hardware-Sensor"
        #[cfg(any(feature = "all", all(feature = "android-hardware-Sensor")))]
        pub fn getDefaultSensor_int<'env>(&'env self, arg0: i32) -> __jni_bindgen::std::result::Result<__jni_bindgen::std::option::Option<__jni_bindgen::Local<'env, crate::android::hardware::Sensor>>, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "getDefaultSensor", .descriptor == "(I)Landroid/hardware/Sensor;"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0)];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "getDefaultSensor\0", "(I)Landroid/hardware/Sensor;\0");
                __jni_env.call_object_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [getDefaultSensor](https://developer.android.com/reference/android/hardware/SensorManager.html#getDefaultSensor(int,%20boolean))
        ///
        /// Required features: "android-hardware-Sensor"
        #[cfg(any(feature = "all", all(feature = "android-hardware-Sensor")))]
        pub fn getDefaultSensor_int_boolean<'env>(&'env self, arg0: i32, arg1: bool) -> __jni_bindgen::std::result::Result<__jni_bindgen::std::option::Option<__jni_bindgen::Local<'env, crate::android::hardware::Sensor>>, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "getDefaultSensor", .descriptor == "(IZ)Landroid/hardware/Sensor;"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0), __jni_bindgen::AsJValue::as_jvalue(&arg1)];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "getDefaultSensor\0", "(IZ)Landroid/hardware/Sensor;\0");
                __jni_env.call_object_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [registerListener](https://developer.android.com/reference/android/hardware/SensorManager.html#registerListener(android.hardware.SensorListener,%20int))
        ///
        /// Required features: "android-hardware-SensorListener"
        #[cfg(any(feature = "all", all(feature = "android-hardware-SensorListener")))]
        #[deprecated] pub fn registerListener_SensorListener_int<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::SensorListener>>, arg1: i32) -> __jni_bindgen::std::result::Result<bool, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "registerListener", .descriptor == "(Landroid/hardware/SensorListener;I)Z"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1)];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "registerListener\0", "(Landroid/hardware/SensorListener;I)Z\0");
                __jni_env.call_boolean_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [registerListener](https://developer.android.com/reference/android/hardware/SensorManager.html#registerListener(android.hardware.SensorListener,%20int,%20int))
        ///
        /// Required features: "android-hardware-SensorListener"
        #[cfg(any(feature = "all", all(feature = "android-hardware-SensorListener")))]
        #[deprecated] pub fn registerListener_SensorListener_int_int<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::SensorListener>>, arg1: i32, arg2: i32) -> __jni_bindgen::std::result::Result<bool, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "registerListener", .descriptor == "(Landroid/hardware/SensorListener;II)Z"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1), __jni_bindgen::AsJValue::as_jvalue(&arg2)];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "registerListener\0", "(Landroid/hardware/SensorListener;II)Z\0");
                __jni_env.call_boolean_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [unregisterListener](https://developer.android.com/reference/android/hardware/SensorManager.html#unregisterListener(android.hardware.SensorListener))
        ///
        /// Required features: "android-hardware-SensorListener"
        #[cfg(any(feature = "all", all(feature = "android-hardware-SensorListener")))]
        #[deprecated] pub fn unregisterListener_SensorListener<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::SensorListener>>) -> __jni_bindgen::std::result::Result<(), __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "unregisterListener", .descriptor == "(Landroid/hardware/SensorListener;)V"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into())];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "unregisterListener\0", "(Landroid/hardware/SensorListener;)V\0");
                __jni_env.call_void_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [unregisterListener](https://developer.android.com/reference/android/hardware/SensorManager.html#unregisterListener(android.hardware.SensorListener,%20int))
        ///
        /// Required features: "android-hardware-SensorListener"
        #[cfg(any(feature = "all", all(feature = "android-hardware-SensorListener")))]
        #[deprecated] pub fn unregisterListener_SensorListener_int<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::SensorListener>>, arg1: i32) -> __jni_bindgen::std::result::Result<(), __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "unregisterListener", .descriptor == "(Landroid/hardware/SensorListener;I)V"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1)];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "unregisterListener\0", "(Landroid/hardware/SensorListener;I)V\0");
                __jni_env.call_void_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [unregisterListener](https://developer.android.com/reference/android/hardware/SensorManager.html#unregisterListener(android.hardware.SensorEventListener,%20android.hardware.Sensor))
        ///
        /// Required features: "android-hardware-Sensor", "android-hardware-SensorEventListener"
        #[cfg(any(feature = "all", all(feature = "android-hardware-Sensor", feature = "android-hardware-SensorEventListener")))]
        pub fn unregisterListener_SensorEventListener_Sensor<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::SensorEventListener>>, arg1: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::Sensor>>) -> __jni_bindgen::std::result::Result<(), __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "unregisterListener", .descriptor == "(Landroid/hardware/SensorEventListener;Landroid/hardware/Sensor;)V"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1.into())];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "unregisterListener\0", "(Landroid/hardware/SensorEventListener;Landroid/hardware/Sensor;)V\0");
                __jni_env.call_void_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [unregisterListener](https://developer.android.com/reference/android/hardware/SensorManager.html#unregisterListener(android.hardware.SensorEventListener))
        ///
        /// Required features: "android-hardware-SensorEventListener"
        #[cfg(any(feature = "all", all(feature = "android-hardware-SensorEventListener")))]
        pub fn unregisterListener_SensorEventListener<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::SensorEventListener>>) -> __jni_bindgen::std::result::Result<(), __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "unregisterListener", .descriptor == "(Landroid/hardware/SensorEventListener;)V"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into())];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "unregisterListener\0", "(Landroid/hardware/SensorEventListener;)V\0");
                __jni_env.call_void_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [registerListener](https://developer.android.com/reference/android/hardware/SensorManager.html#registerListener(android.hardware.SensorEventListener,%20android.hardware.Sensor,%20int))
        ///
        /// Required features: "android-hardware-Sensor", "android-hardware-SensorEventListener"
        #[cfg(any(feature = "all", all(feature = "android-hardware-Sensor", feature = "android-hardware-SensorEventListener")))]
        pub fn registerListener_SensorEventListener_Sensor_int<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::SensorEventListener>>, arg1: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::Sensor>>, arg2: i32) -> __jni_bindgen::std::result::Result<bool, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "registerListener", .descriptor == "(Landroid/hardware/SensorEventListener;Landroid/hardware/Sensor;I)Z"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1.into()), __jni_bindgen::AsJValue::as_jvalue(&arg2)];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "registerListener\0", "(Landroid/hardware/SensorEventListener;Landroid/hardware/Sensor;I)Z\0");
                __jni_env.call_boolean_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [registerListener](https://developer.android.com/reference/android/hardware/SensorManager.html#registerListener(android.hardware.SensorEventListener,%20android.hardware.Sensor,%20int,%20int))
        ///
        /// Required features: "android-hardware-Sensor", "android-hardware-SensorEventListener"
        #[cfg(any(feature = "all", all(feature = "android-hardware-Sensor", feature = "android-hardware-SensorEventListener")))]
        pub fn registerListener_SensorEventListener_Sensor_int_int<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::SensorEventListener>>, arg1: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::Sensor>>, arg2: i32, arg3: i32) -> __jni_bindgen::std::result::Result<bool, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "registerListener", .descriptor == "(Landroid/hardware/SensorEventListener;Landroid/hardware/Sensor;II)Z"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1.into()), __jni_bindgen::AsJValue::as_jvalue(&arg2), __jni_bindgen::AsJValue::as_jvalue(&arg3)];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "registerListener\0", "(Landroid/hardware/SensorEventListener;Landroid/hardware/Sensor;II)Z\0");
                __jni_env.call_boolean_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [registerListener](https://developer.android.com/reference/android/hardware/SensorManager.html#registerListener(android.hardware.SensorEventListener,%20android.hardware.Sensor,%20int,%20android.os.Handler))
        ///
        /// Required features: "android-hardware-Sensor", "android-hardware-SensorEventListener", "android-os-Handler"
        #[cfg(any(feature = "all", all(feature = "android-hardware-Sensor", feature = "android-hardware-SensorEventListener", feature = "android-os-Handler")))]
        pub fn registerListener_SensorEventListener_Sensor_int_Handler<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::SensorEventListener>>, arg1: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::Sensor>>, arg2: i32, arg3: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::os::Handler>>) -> __jni_bindgen::std::result::Result<bool, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "registerListener", .descriptor == "(Landroid/hardware/SensorEventListener;Landroid/hardware/Sensor;ILandroid/os/Handler;)Z"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1.into()), __jni_bindgen::AsJValue::as_jvalue(&arg2), __jni_bindgen::AsJValue::as_jvalue(&arg3.into())];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "registerListener\0", "(Landroid/hardware/SensorEventListener;Landroid/hardware/Sensor;ILandroid/os/Handler;)Z\0");
                __jni_env.call_boolean_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [registerListener](https://developer.android.com/reference/android/hardware/SensorManager.html#registerListener(android.hardware.SensorEventListener,%20android.hardware.Sensor,%20int,%20int,%20android.os.Handler))
        ///
        /// Required features: "android-hardware-Sensor", "android-hardware-SensorEventListener", "android-os-Handler"
        #[cfg(any(feature = "all", all(feature = "android-hardware-Sensor", feature = "android-hardware-SensorEventListener", feature = "android-os-Handler")))]
        pub fn registerListener_SensorEventListener_Sensor_int_int_Handler<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::SensorEventListener>>, arg1: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::Sensor>>, arg2: i32, arg3: i32, arg4: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::os::Handler>>) -> __jni_bindgen::std::result::Result<bool, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "registerListener", .descriptor == "(Landroid/hardware/SensorEventListener;Landroid/hardware/Sensor;IILandroid/os/Handler;)Z"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1.into()), __jni_bindgen::AsJValue::as_jvalue(&arg2), __jni_bindgen::AsJValue::as_jvalue(&arg3), __jni_bindgen::AsJValue::as_jvalue(&arg4.into())];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "registerListener\0", "(Landroid/hardware/SensorEventListener;Landroid/hardware/Sensor;IILandroid/os/Handler;)Z\0");
                __jni_env.call_boolean_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [flush](https://developer.android.com/reference/android/hardware/SensorManager.html#flush(android.hardware.SensorEventListener))
        ///
        /// Required features: "android-hardware-SensorEventListener"
        #[cfg(any(feature = "all", all(feature = "android-hardware-SensorEventListener")))]
        pub fn flush<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::SensorEventListener>>) -> __jni_bindgen::std::result::Result<bool, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "flush", .descriptor == "(Landroid/hardware/SensorEventListener;)Z"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into())];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "flush\0", "(Landroid/hardware/SensorEventListener;)Z\0");
                __jni_env.call_boolean_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [createDirectChannel](https://developer.android.com/reference/android/hardware/SensorManager.html#createDirectChannel(android.os.MemoryFile))
        ///
        /// Required features: "android-hardware-SensorDirectChannel", "android-os-MemoryFile"
        #[cfg(any(feature = "all", all(feature = "android-hardware-SensorDirectChannel", feature = "android-os-MemoryFile")))]
        pub fn createDirectChannel_MemoryFile<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::os::MemoryFile>>) -> __jni_bindgen::std::result::Result<__jni_bindgen::std::option::Option<__jni_bindgen::Local<'env, crate::android::hardware::SensorDirectChannel>>, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "createDirectChannel", .descriptor == "(Landroid/os/MemoryFile;)Landroid/hardware/SensorDirectChannel;"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into())];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "createDirectChannel\0", "(Landroid/os/MemoryFile;)Landroid/hardware/SensorDirectChannel;\0");
                __jni_env.call_object_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [createDirectChannel](https://developer.android.com/reference/android/hardware/SensorManager.html#createDirectChannel(android.hardware.HardwareBuffer))
        ///
        /// Required features: "android-hardware-HardwareBuffer", "android-hardware-SensorDirectChannel"
        #[cfg(any(feature = "all", all(feature = "android-hardware-HardwareBuffer", feature = "android-hardware-SensorDirectChannel")))]
        pub fn createDirectChannel_HardwareBuffer<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::HardwareBuffer>>) -> __jni_bindgen::std::result::Result<__jni_bindgen::std::option::Option<__jni_bindgen::Local<'env, crate::android::hardware::SensorDirectChannel>>, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "createDirectChannel", .descriptor == "(Landroid/hardware/HardwareBuffer;)Landroid/hardware/SensorDirectChannel;"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into())];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "createDirectChannel\0", "(Landroid/hardware/HardwareBuffer;)Landroid/hardware/SensorDirectChannel;\0");
                __jni_env.call_object_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [registerDynamicSensorCallback](https://developer.android.com/reference/android/hardware/SensorManager.html#registerDynamicSensorCallback(android.hardware.SensorManager.DynamicSensorCallback))
        ///
        /// Required features: "android-hardware-SensorManager_DynamicSensorCallback"
        #[cfg(any(feature = "all", all(feature = "android-hardware-SensorManager_DynamicSensorCallback")))]
        pub fn registerDynamicSensorCallback_DynamicSensorCallback<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::SensorManager_DynamicSensorCallback>>) -> __jni_bindgen::std::result::Result<(), __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "registerDynamicSensorCallback", .descriptor == "(Landroid/hardware/SensorManager$DynamicSensorCallback;)V"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into())];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "registerDynamicSensorCallback\0", "(Landroid/hardware/SensorManager$DynamicSensorCallback;)V\0");
                __jni_env.call_void_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [registerDynamicSensorCallback](https://developer.android.com/reference/android/hardware/SensorManager.html#registerDynamicSensorCallback(android.hardware.SensorManager.DynamicSensorCallback,%20android.os.Handler))
        ///
        /// Required features: "android-hardware-SensorManager_DynamicSensorCallback", "android-os-Handler"
        #[cfg(any(feature = "all", all(feature = "android-hardware-SensorManager_DynamicSensorCallback", feature = "android-os-Handler")))]
        pub fn registerDynamicSensorCallback_DynamicSensorCallback_Handler<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::SensorManager_DynamicSensorCallback>>, arg1: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::os::Handler>>) -> __jni_bindgen::std::result::Result<(), __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "registerDynamicSensorCallback", .descriptor == "(Landroid/hardware/SensorManager$DynamicSensorCallback;Landroid/os/Handler;)V"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1.into())];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "registerDynamicSensorCallback\0", "(Landroid/hardware/SensorManager$DynamicSensorCallback;Landroid/os/Handler;)V\0");
                __jni_env.call_void_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [unregisterDynamicSensorCallback](https://developer.android.com/reference/android/hardware/SensorManager.html#unregisterDynamicSensorCallback(android.hardware.SensorManager.DynamicSensorCallback))
        ///
        /// Required features: "android-hardware-SensorManager_DynamicSensorCallback"
        #[cfg(any(feature = "all", all(feature = "android-hardware-SensorManager_DynamicSensorCallback")))]
        pub fn unregisterDynamicSensorCallback<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::SensorManager_DynamicSensorCallback>>) -> __jni_bindgen::std::result::Result<(), __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "unregisterDynamicSensorCallback", .descriptor == "(Landroid/hardware/SensorManager$DynamicSensorCallback;)V"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into())];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "unregisterDynamicSensorCallback\0", "(Landroid/hardware/SensorManager$DynamicSensorCallback;)V\0");
                __jni_env.call_void_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [isDynamicSensorDiscoverySupported](https://developer.android.com/reference/android/hardware/SensorManager.html#isDynamicSensorDiscoverySupported())
        pub fn isDynamicSensorDiscoverySupported<'env>(&'env self) -> __jni_bindgen::std::result::Result<bool, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "isDynamicSensorDiscoverySupported", .descriptor == "()Z"
            unsafe {
                let __jni_args = [];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "isDynamicSensorDiscoverySupported\0", "()Z\0");
                __jni_env.call_boolean_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [getRotationMatrix](https://developer.android.com/reference/android/hardware/SensorManager.html#getRotationMatrix(float%5B%5D,%20float%5B%5D,%20float%5B%5D,%20float%5B%5D))
        pub fn getRotationMatrix<'env>(__jni_env: &'env __jni_bindgen::Env, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>, arg1: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>, arg2: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>, arg3: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>) -> __jni_bindgen::std::result::Result<bool, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC | STATIC, .name == "getRotationMatrix", .descriptor == "([F[F[F[F)Z"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1.into()), __jni_bindgen::AsJValue::as_jvalue(&arg2.into()), __jni_bindgen::AsJValue::as_jvalue(&arg3.into())];
                let (__jni_class, __jni_method) = __jni_env.require_class_static_method("android/hardware/SensorManager\0", "getRotationMatrix\0", "([F[F[F[F)Z\0");
                __jni_env.call_static_boolean_method_a(__jni_class, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [getInclination](https://developer.android.com/reference/android/hardware/SensorManager.html#getInclination(float%5B%5D))
        pub fn getInclination<'env>(__jni_env: &'env __jni_bindgen::Env, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>) -> __jni_bindgen::std::result::Result<f32, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC | STATIC, .name == "getInclination", .descriptor == "([F)F"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into())];
                let (__jni_class, __jni_method) = __jni_env.require_class_static_method("android/hardware/SensorManager\0", "getInclination\0", "([F)F\0");
                __jni_env.call_static_float_method_a(__jni_class, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [remapCoordinateSystem](https://developer.android.com/reference/android/hardware/SensorManager.html#remapCoordinateSystem(float%5B%5D,%20int,%20int,%20float%5B%5D))
        pub fn remapCoordinateSystem<'env>(__jni_env: &'env __jni_bindgen::Env, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>, arg1: i32, arg2: i32, arg3: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>) -> __jni_bindgen::std::result::Result<bool, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC | STATIC, .name == "remapCoordinateSystem", .descriptor == "([FII[F)Z"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1), __jni_bindgen::AsJValue::as_jvalue(&arg2), __jni_bindgen::AsJValue::as_jvalue(&arg3.into())];
                let (__jni_class, __jni_method) = __jni_env.require_class_static_method("android/hardware/SensorManager\0", "remapCoordinateSystem\0", "([FII[F)Z\0");
                __jni_env.call_static_boolean_method_a(__jni_class, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [getOrientation](https://developer.android.com/reference/android/hardware/SensorManager.html#getOrientation(float%5B%5D,%20float%5B%5D))
        pub fn getOrientation<'env>(__jni_env: &'env __jni_bindgen::Env, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>, arg1: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>) -> __jni_bindgen::std::result::Result<__jni_bindgen::std::option::Option<__jni_bindgen::Local<'env, __jni_bindgen::FloatArray>>, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC | STATIC, .name == "getOrientation", .descriptor == "([F[F)[F"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1.into())];
                let (__jni_class, __jni_method) = __jni_env.require_class_static_method("android/hardware/SensorManager\0", "getOrientation\0", "([F[F)[F\0");
                __jni_env.call_static_object_method_a(__jni_class, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [getAltitude](https://developer.android.com/reference/android/hardware/SensorManager.html#getAltitude(float,%20float))
        pub fn getAltitude<'env>(__jni_env: &'env __jni_bindgen::Env, arg0: f32, arg1: f32) -> __jni_bindgen::std::result::Result<f32, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC | STATIC, .name == "getAltitude", .descriptor == "(FF)F"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0), __jni_bindgen::AsJValue::as_jvalue(&arg1)];
                let (__jni_class, __jni_method) = __jni_env.require_class_static_method("android/hardware/SensorManager\0", "getAltitude\0", "(FF)F\0");
                __jni_env.call_static_float_method_a(__jni_class, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [getAngleChange](https://developer.android.com/reference/android/hardware/SensorManager.html#getAngleChange(float%5B%5D,%20float%5B%5D,%20float%5B%5D))
        pub fn getAngleChange<'env>(__jni_env: &'env __jni_bindgen::Env, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>, arg1: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>, arg2: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>) -> __jni_bindgen::std::result::Result<(), __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC | STATIC, .name == "getAngleChange", .descriptor == "([F[F[F)V"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1.into()), __jni_bindgen::AsJValue::as_jvalue(&arg2.into())];
                let (__jni_class, __jni_method) = __jni_env.require_class_static_method("android/hardware/SensorManager\0", "getAngleChange\0", "([F[F[F)V\0");
                __jni_env.call_static_void_method_a(__jni_class, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [getRotationMatrixFromVector](https://developer.android.com/reference/android/hardware/SensorManager.html#getRotationMatrixFromVector(float%5B%5D,%20float%5B%5D))
        pub fn getRotationMatrixFromVector<'env>(__jni_env: &'env __jni_bindgen::Env, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>, arg1: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>) -> __jni_bindgen::std::result::Result<(), __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC | STATIC, .name == "getRotationMatrixFromVector", .descriptor == "([F[F)V"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1.into())];
                let (__jni_class, __jni_method) = __jni_env.require_class_static_method("android/hardware/SensorManager\0", "getRotationMatrixFromVector\0", "([F[F)V\0");
                __jni_env.call_static_void_method_a(__jni_class, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [getQuaternionFromVector](https://developer.android.com/reference/android/hardware/SensorManager.html#getQuaternionFromVector(float%5B%5D,%20float%5B%5D))
        pub fn getQuaternionFromVector<'env>(__jni_env: &'env __jni_bindgen::Env, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>, arg1: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env __jni_bindgen::FloatArray>>) -> __jni_bindgen::std::result::Result<(), __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC | STATIC, .name == "getQuaternionFromVector", .descriptor == "([F[F)V"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1.into())];
                let (__jni_class, __jni_method) = __jni_env.require_class_static_method("android/hardware/SensorManager\0", "getQuaternionFromVector\0", "([F[F)V\0");
                __jni_env.call_static_void_method_a(__jni_class, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [requestTriggerSensor](https://developer.android.com/reference/android/hardware/SensorManager.html#requestTriggerSensor(android.hardware.TriggerEventListener,%20android.hardware.Sensor))
        ///
        /// Required features: "android-hardware-Sensor", "android-hardware-TriggerEventListener"
        #[cfg(any(feature = "all", all(feature = "android-hardware-Sensor", feature = "android-hardware-TriggerEventListener")))]
        pub fn requestTriggerSensor<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::TriggerEventListener>>, arg1: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::Sensor>>) -> __jni_bindgen::std::result::Result<bool, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "requestTriggerSensor", .descriptor == "(Landroid/hardware/TriggerEventListener;Landroid/hardware/Sensor;)Z"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1.into())];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "requestTriggerSensor\0", "(Landroid/hardware/TriggerEventListener;Landroid/hardware/Sensor;)Z\0");
                __jni_env.call_boolean_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// [cancelTriggerSensor](https://developer.android.com/reference/android/hardware/SensorManager.html#cancelTriggerSensor(android.hardware.TriggerEventListener,%20android.hardware.Sensor))
        ///
        /// Required features: "android-hardware-Sensor", "android-hardware-TriggerEventListener"
        #[cfg(any(feature = "all", all(feature = "android-hardware-Sensor", feature = "android-hardware-TriggerEventListener")))]
        pub fn cancelTriggerSensor<'env>(&'env self, arg0: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::TriggerEventListener>>, arg1: impl __jni_bindgen::std::convert::Into<__jni_bindgen::std::option::Option<&'env crate::android::hardware::Sensor>>) -> __jni_bindgen::std::result::Result<bool, __jni_bindgen::Local<'env, crate::java::lang::Throwable>> {
            // class.path == "android/hardware/SensorManager", java.flags == PUBLIC, .name == "cancelTriggerSensor", .descriptor == "(Landroid/hardware/TriggerEventListener;Landroid/hardware/Sensor;)Z"
            unsafe {
                let __jni_args = [__jni_bindgen::AsJValue::as_jvalue(&arg0.into()), __jni_bindgen::AsJValue::as_jvalue(&arg1.into())];
                let __jni_env = __jni_bindgen::Env::from_ptr(self.0.env);
                let (__jni_class, __jni_method) = __jni_env.require_class_method("android/hardware/SensorManager\0", "cancelTriggerSensor\0", "(Landroid/hardware/TriggerEventListener;Landroid/hardware/Sensor;)Z\0");
                __jni_env.call_boolean_method_a(self.0.object, __jni_method, __jni_args.as_ptr())
            }
        }

        /// public static final [AXIS_MINUS_X](https://developer.android.com/reference/android/hardware/SensorManager.html#AXIS_MINUS_X)
        pub const AXIS_MINUS_X : i32 = 129;

        /// public static final [AXIS_MINUS_Y](https://developer.android.com/reference/android/hardware/SensorManager.html#AXIS_MINUS_Y)
        pub const AXIS_MINUS_Y : i32 = 130;

        /// public static final [AXIS_MINUS_Z](https://developer.android.com/reference/android/hardware/SensorManager.html#AXIS_MINUS_Z)
        pub const AXIS_MINUS_Z : i32 = 131;

        /// public static final [AXIS_X](https://developer.android.com/reference/android/hardware/SensorManager.html#AXIS_X)
        pub const AXIS_X : i32 = 1;

        /// public static final [AXIS_Y](https://developer.android.com/reference/android/hardware/SensorManager.html#AXIS_Y)
        pub const AXIS_Y : i32 = 2;

        /// public static final [AXIS_Z](https://developer.android.com/reference/android/hardware/SensorManager.html#AXIS_Z)
        pub const AXIS_Z : i32 = 3;

        /// public static final [DATA_X](https://developer.android.com/reference/android/hardware/SensorManager.html#DATA_X)
        #[deprecated] pub const DATA_X : i32 = 0;

        /// public static final [DATA_Y](https://developer.android.com/reference/android/hardware/SensorManager.html#DATA_Y)
        #[deprecated] pub const DATA_Y : i32 = 1;

        /// public static final [DATA_Z](https://developer.android.com/reference/android/hardware/SensorManager.html#DATA_Z)
        #[deprecated] pub const DATA_Z : i32 = 2;

        /// public static final [GRAVITY_DEATH_STAR_I](https://developer.android.com/reference/android/hardware/SensorManager.html#GRAVITY_DEATH_STAR_I)
        pub const GRAVITY_DEATH_STAR_I : f32 = 0.00000035303614f32;

        /// public static final [GRAVITY_EARTH](https://developer.android.com/reference/android/hardware/SensorManager.html#GRAVITY_EARTH)
        pub const GRAVITY_EARTH : f32 = 9.80665f32;

        /// public static final [GRAVITY_JUPITER](https://developer.android.com/reference/android/hardware/SensorManager.html#GRAVITY_JUPITER)
        pub const GRAVITY_JUPITER : f32 = 23.12f32;

        /// public static final [GRAVITY_MARS](https://developer.android.com/reference/android/hardware/SensorManager.html#GRAVITY_MARS)
        pub const GRAVITY_MARS : f32 = 3.71f32;

        /// public static final [GRAVITY_MERCURY](https://developer.android.com/reference/android/hardware/SensorManager.html#GRAVITY_MERCURY)
        pub const GRAVITY_MERCURY : f32 = 3.7f32;

        /// public static final [GRAVITY_MOON](https://developer.android.com/reference/android/hardware/SensorManager.html#GRAVITY_MOON)
        pub const GRAVITY_MOON : f32 = 1.6f32;

        /// public static final [GRAVITY_NEPTUNE](https://developer.android.com/reference/android/hardware/SensorManager.html#GRAVITY_NEPTUNE)
        pub const GRAVITY_NEPTUNE : f32 = 11f32;

        /// public static final [GRAVITY_PLUTO](https://developer.android.com/reference/android/hardware/SensorManager.html#GRAVITY_PLUTO)
        pub const GRAVITY_PLUTO : f32 = 0.6f32;

        /// public static final [GRAVITY_SATURN](https://developer.android.com/reference/android/hardware/SensorManager.html#GRAVITY_SATURN)
        pub const GRAVITY_SATURN : f32 = 8.96f32;

        /// public static final [GRAVITY_SUN](https://developer.android.com/reference/android/hardware/SensorManager.html#GRAVITY_SUN)
        pub const GRAVITY_SUN : f32 = 275f32;

        /// public static final [GRAVITY_THE_ISLAND](https://developer.android.com/reference/android/hardware/SensorManager.html#GRAVITY_THE_ISLAND)
        pub const GRAVITY_THE_ISLAND : f32 = 4.815162f32;

        /// public static final [GRAVITY_URANUS](https://developer.android.com/reference/android/hardware/SensorManager.html#GRAVITY_URANUS)
        pub const GRAVITY_URANUS : f32 = 8.69f32;

        /// public static final [GRAVITY_VENUS](https://developer.android.com/reference/android/hardware/SensorManager.html#GRAVITY_VENUS)
        pub const GRAVITY_VENUS : f32 = 8.87f32;

        /// public static final [LIGHT_CLOUDY](https://developer.android.com/reference/android/hardware/SensorManager.html#LIGHT_CLOUDY)
        pub const LIGHT_CLOUDY : f32 = 100f32;

        /// public static final [LIGHT_FULLMOON](https://developer.android.com/reference/android/hardware/SensorManager.html#LIGHT_FULLMOON)
        pub const LIGHT_FULLMOON : f32 = 0.25f32;

        /// public static final [LIGHT_NO_MOON](https://developer.android.com/reference/android/hardware/SensorManager.html#LIGHT_NO_MOON)
        pub const LIGHT_NO_MOON : f32 = 0.001f32;

        /// public static final [LIGHT_OVERCAST](https://developer.android.com/reference/android/hardware/SensorManager.html#LIGHT_OVERCAST)
        pub const LIGHT_OVERCAST : f32 = 10000f32;

        /// public static final [LIGHT_SHADE](https://developer.android.com/reference/android/hardware/SensorManager.html#LIGHT_SHADE)
        pub const LIGHT_SHADE : f32 = 20000f32;

        /// public static final [LIGHT_SUNLIGHT](https://developer.android.com/reference/android/hardware/SensorManager.html#LIGHT_SUNLIGHT)
        pub const LIGHT_SUNLIGHT : f32 = 110000f32;

        /// public static final [LIGHT_SUNLIGHT_MAX](https://developer.android.com/reference/android/hardware/SensorManager.html#LIGHT_SUNLIGHT_MAX)
        pub const LIGHT_SUNLIGHT_MAX : f32 = 120000f32;

        /// public static final [LIGHT_SUNRISE](https://developer.android.com/reference/android/hardware/SensorManager.html#LIGHT_SUNRISE)
        pub const LIGHT_SUNRISE : f32 = 400f32;

        /// public static final [MAGNETIC_FIELD_EARTH_MAX](https://developer.android.com/reference/android/hardware/SensorManager.html#MAGNETIC_FIELD_EARTH_MAX)
        pub const MAGNETIC_FIELD_EARTH_MAX : f32 = 60f32;

        /// public static final [MAGNETIC_FIELD_EARTH_MIN](https://developer.android.com/reference/android/hardware/SensorManager.html#MAGNETIC_FIELD_EARTH_MIN)
        pub const MAGNETIC_FIELD_EARTH_MIN : f32 = 30f32;

        /// public static final [PRESSURE_STANDARD_ATMOSPHERE](https://developer.android.com/reference/android/hardware/SensorManager.html#PRESSURE_STANDARD_ATMOSPHERE)
        pub const PRESSURE_STANDARD_ATMOSPHERE : f32 = 1013.25f32;

        /// public static final [RAW_DATA_INDEX](https://developer.android.com/reference/android/hardware/SensorManager.html#RAW_DATA_INDEX)
        #[deprecated] pub const RAW_DATA_INDEX : i32 = 3;

        /// public static final [RAW_DATA_X](https://developer.android.com/reference/android/hardware/SensorManager.html#RAW_DATA_X)
        #[deprecated] pub const RAW_DATA_X : i32 = 3;

        /// public static final [RAW_DATA_Y](https://developer.android.com/reference/android/hardware/SensorManager.html#RAW_DATA_Y)
        #[deprecated] pub const RAW_DATA_Y : i32 = 4;

        /// public static final [RAW_DATA_Z](https://developer.android.com/reference/android/hardware/SensorManager.html#RAW_DATA_Z)
        #[deprecated] pub const RAW_DATA_Z : i32 = 5;

        /// public static final [SENSOR_ACCELEROMETER](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_ACCELEROMETER)
        #[deprecated] pub const SENSOR_ACCELEROMETER : i32 = 2;

        /// public static final [SENSOR_ALL](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_ALL)
        #[deprecated] pub const SENSOR_ALL : i32 = 127;

        /// public static final [SENSOR_DELAY_FASTEST](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_DELAY_FASTEST)
        pub const SENSOR_DELAY_FASTEST : i32 = 0;

        /// public static final [SENSOR_DELAY_GAME](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_DELAY_GAME)
        pub const SENSOR_DELAY_GAME : i32 = 1;

        /// public static final [SENSOR_DELAY_NORMAL](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_DELAY_NORMAL)
        pub const SENSOR_DELAY_NORMAL : i32 = 3;

        /// public static final [SENSOR_DELAY_UI](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_DELAY_UI)
        pub const SENSOR_DELAY_UI : i32 = 2;

        /// public static final [SENSOR_LIGHT](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_LIGHT)
        #[deprecated] pub const SENSOR_LIGHT : i32 = 16;

        /// public static final [SENSOR_MAGNETIC_FIELD](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_MAGNETIC_FIELD)
        #[deprecated] pub const SENSOR_MAGNETIC_FIELD : i32 = 8;

        /// public static final [SENSOR_MAX](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_MAX)
        #[deprecated] pub const SENSOR_MAX : i32 = 64;

        /// public static final [SENSOR_MIN](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_MIN)
        #[deprecated] pub const SENSOR_MIN : i32 = 1;

        /// public static final [SENSOR_ORIENTATION](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_ORIENTATION)
        #[deprecated] pub const SENSOR_ORIENTATION : i32 = 1;

        /// public static final [SENSOR_ORIENTATION_RAW](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_ORIENTATION_RAW)
        #[deprecated] pub const SENSOR_ORIENTATION_RAW : i32 = 128;

        /// public static final [SENSOR_PROXIMITY](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_PROXIMITY)
        #[deprecated] pub const SENSOR_PROXIMITY : i32 = 32;

        /// public static final [SENSOR_STATUS_ACCURACY_HIGH](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_STATUS_ACCURACY_HIGH)
        pub const SENSOR_STATUS_ACCURACY_HIGH : i32 = 3;

        /// public static final [SENSOR_STATUS_ACCURACY_LOW](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_STATUS_ACCURACY_LOW)
        pub const SENSOR_STATUS_ACCURACY_LOW : i32 = 1;

        /// public static final [SENSOR_STATUS_ACCURACY_MEDIUM](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_STATUS_ACCURACY_MEDIUM)
        pub const SENSOR_STATUS_ACCURACY_MEDIUM : i32 = 2;

        /// public static final [SENSOR_STATUS_NO_CONTACT](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_STATUS_NO_CONTACT)
        pub const SENSOR_STATUS_NO_CONTACT : i32 = -1;

        /// public static final [SENSOR_STATUS_UNRELIABLE](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_STATUS_UNRELIABLE)
        pub const SENSOR_STATUS_UNRELIABLE : i32 = 0;

        /// public static final [SENSOR_TEMPERATURE](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_TEMPERATURE)
        #[deprecated] pub const SENSOR_TEMPERATURE : i32 = 4;

        /// public static final [SENSOR_TRICORDER](https://developer.android.com/reference/android/hardware/SensorManager.html#SENSOR_TRICORDER)
        #[deprecated] pub const SENSOR_TRICORDER : i32 = 64;

        /// public static final [STANDARD_GRAVITY](https://developer.android.com/reference/android/hardware/SensorManager.html#STANDARD_GRAVITY)
        pub const STANDARD_GRAVITY : f32 = 9.80665f32;
    }
}
