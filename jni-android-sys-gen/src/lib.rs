use bugsalot::debugger;

use clap::load_yaml;

use std::fs::File;
use std::io::{self, BufRead, BufReader, BufWriter, Write};

use std::ops::*;
use std::path::*;
use std::process::exit;

pub fn generate(output_dir: &Path, min_api_level: i32, max_api_level: i32, android_sdk: Option<&str>) {
    if min_api_level < 7 {
        eprintln!(
            "\
             WARNING:  Untested api level {} (<7).\n\
             If you've found where I can grab such an early version of the Android SDK/APIs,\n\
             please comment on / reopen https://github.com/MaulingMonkey/jni-bindgen/issues/10 !",
            min_api_level
        );
    }

    let api_levels = min_api_level..=max_api_level;

    let mut config_file = jni_bindgen::config::toml::File::from_directory(output_dir).unwrap();

    let mut result = None;
    for api_level in api_levels.clone() {
        let sdk_android_jar = if android_sdk.is_some() {
            format!("{}/platforms/android-{}/android.jar", android_sdk.unwrap(), api_level)
        } else if std::env::var_os("ANDROID_HOME").is_some() {
            format!("%ANDROID_HOME%/platforms/android-{}/android.jar", api_level)
        } else {
            panic!("Android SDK root directory must either be defined as ANDROID_HOME environment variable or passed as the --android-sdk CLI argument");
        };

        config_file.file.input.files.clear();
        config_file.file.input.files.push(PathBuf::from(sdk_android_jar));
        config_file.file.output.path = PathBuf::from(format!("src/generated/api-level-{}.rs", api_level));
        match jni_bindgen::run(config_file.clone()) {
            Ok(res) => {
                result = Some(res);
            }
            Err(_e) => {
                //                        dbg!(e);
            }
        };
    }
    let result = result.unwrap();

//    if let Err(e) = generate_toml(output_dir, api_levels.clone(), &result) {
//        eprintln!("ERROR:  Failed to regenerate Cargo.toml:\n    {:?}", e);
//        exit(1);
//    }
}

fn generate_toml(directory: &Path, api_levels: RangeInclusive<i32>, result: &jni_bindgen::RunResult) -> io::Result<()> {
    // XXX: Check that Cargo.toml is marked as generated

    let template = BufReader::new(File::open(directory.join("Cargo.toml.template"))?);
    let mut out = BufWriter::new(File::create(directory.join("Cargo.toml"))?);

    writeln!(out, "# WARNING:  This file was autogenerated by jni-bindgen.  Any changes to this file may be lost!!!")?;
    writeln!(out, "")?;

    for line in template.lines() {
        let line = line?;
        let line = line.trim_end_matches(|ch| ch == '\n' || ch == '\r');
        match line {
            "# PLACEHOLDER:FEATURES:api-level-NN" => {
                writeln!(out, "{}:BEGIN", line)?;
                for api_level in api_levels.clone() {
                    write!(out, "api-level-{} = [", api_level)?;
                    if api_level > *api_levels.start() {
                        write!(out, "\"api-level-{}\"", api_level - 1)?;
                    }
                    writeln!(out, "]")?;
                }
                writeln!(out, "{}:END", line)?;
            }
            "# PLACEHOLDER:FEATURES:sharded-api" => {
                writeln!(out, "{}:BEGIN", line)?;
                for (feature, dependencies) in result.features.iter() {
                    write!(out, "{:?} = [", feature)?;
                    for (idx, dependency) in dependencies.iter().enumerate() {
                        if idx != 0 {
                            write!(out, ", ")?;
                        }
                        write!(out, "{:?}", dependency)?;
                    }
                    writeln!(out, "]")?;
                }

                // Wildcard feature "*".  While it's tempting to make this depend on all other features, this
                // causes problems on windows where we run into command line length limits invoking rustc.
                writeln!(out, "\"all\" = []")?;
                writeln!(out, "{}:END", line)?;
            }
            "# PLACEHOLDER:FEATURES:docs.rs" => {
                writeln!(out, "{}:BEGIN", line)?;
                writeln!(out, "features = [\"all\", \"api-level-{}\", \"force-define\"]", api_levels.end())?;
                writeln!(out, "{}:END", line)?;
            }
            line => {
                if line.starts_with("# PLACEHOLDER:") {
                    eprintln!("WARNING:  Unexpected Cargo.toml placeholder:\n    {}", line);
                }
                writeln!(out, "{}", line)?;
            }
        }
    }

    Ok(())
}
